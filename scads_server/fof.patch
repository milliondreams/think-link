diff --git a/db.rb b/db.rb
new file mode 100644
index 0000000..0f8b6e3
--- /dev/null
+++ b/db.rb
@@ -0,0 +1,34 @@
+require 'scads.rb'
+require 'examples/social.rb'
+
+#profiles = []
+#
+#(0..9).each do |val|
+#  p = Profile.new
+#  p[:birthday] = rand 1000
+#  p[:name] = "person" + val.to_s
+#  p.save
+#  profiles << p
+#end
+#
+#profiles.each_with_index do |prof1,ind1|
+#  profiles.each_with_index do |prof2,ind2|
+#    if (rand 6) == 1 && (ind1 > ind2)
+#      f = Friendship.create(prof1,prof2)
+#      f.save
+#    end
+#  end
+#end
+
+p1 = Profile.new
+p2 = Profile.new
+p1[:birthday] = "jan1"
+p2[:birthday] = "july14"
+p1[:name] = "barret"
+p2[:name] = "jake"
+p1.save
+p2.save
+f = Friendship.create(p1,p2)
+f.save
+
+print SCADS_SERVER
diff --git a/entity/associations.rb b/entity/associations.rb
new file mode 100644
index 0000000..27b3300
--- /dev/null
+++ b/entity/associations.rb
@@ -0,0 +1,23 @@
+require 'active_support'
+
+module Scads
+  module Entity
+    module Associations  
+      def self.included(base)
+        base.extend(ClassMethods)
+      end
+
+      module ClassMethods
+        def has_many(entity_type, field_name = type_name.to_s.downcase)
+          index_name = "belongs_to_#{type_name.to_s.downcase}".intern
+          target = entity_type.to_s.singularize.capitalize.intern
+
+          function = Proc.new do |entity|
+            [entity[field_name.intern].primary_key]
+          end          
+          add_index(index_name, function, target)
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/entity/base.rb b/entity/base.rb
new file mode 100644
index 0000000..f4545d0
--- /dev/null
+++ b/entity/base.rb
@@ -0,0 +1,165 @@
+require 'yaml'
+require 'entity/associations'
+
+module Scads
+  module Entity
+    class PrimaryKey
+      @@count = 0
+      def self.new_primary_key
+        Storage::Key.new(@@count = @@count + 1)
+      end
+    end
+
+    class Base
+      include Associations
+
+      attr_writer :attributes, :stub
+      attr_reader :attributes, :stub
+
+      MAX_ROWS = 100
+      @@indexes = {}
+
+      def self.my_indexes
+        @@indexes[type_name] 
+      end
+
+      #Returns the symbol that is registered with the server to refer to entities represented by this class.
+      def self.type_name
+        self.name.split("::").last.intern
+      end
+
+      #Register a new function that generates secondary keys for this Entity Type
+      def self.indexed_by(method_name)
+        add_index(method_name, instance_method(method_name))
+      end
+
+      #Return a list of indexes that have been registered for this entity type
+      def self.index_names
+        return @@indexes[type_name].nil? ? [] : @@indexes[type_name].keys
+      end
+
+      def self.get_class(type_name)
+        Object.const_get(type_name)
+      end
+
+      #Look up and instantiate an entity from the server by primary_key
+      def self.find(primary_key)
+        SCADS_SERVER.get(self.type_name, :primary_table, primary_key, 0 , 0).first
+      end
+
+      def self.method_missing(method_id, *args, &block)
+        unless ((match = method_id.to_s.match(/find_by_(\S+)/)).nil?)
+          index = match[1].intern
+          key = args[0]
+          start_range = args[1] || 0
+          end_range = args[2] || MAX_ROWS
+
+          raise "Invalid Index Specified" unless index_names.member?(index)
+
+          return SCADS_SERVER.get(self.type_name, index, key, start_range, end_range)
+        end
+        raise "Invalid Method"
+      end
+
+      def == other
+        self.primary_key == other.primary_key
+      end
+
+      #Create a new entity
+      def initialize(primary_key = PrimaryKey::new_primary_key, attributes = {}, stub = false)
+        @primary_key = primary_key
+        @attributes = attributes
+        @stub = stub
+      end
+
+      #Returns the primary_key for this entity
+      def primary_key
+        @primary_key
+      end
+
+      def [](attribute_name)
+        load_stub if @stub
+        @attributes[attribute_name]
+      end
+
+      def []=(attribute_name, value)
+        load_stub if @stub
+        @attributes[attribute_name] = value
+      end
+
+      # Store the attributes of this entity to the server.  This will cause any secondary indexes to be recomputed async
+      # anything that might be stubified downstream needs to be duped, at each layer (i think, will have to think more)
+      # definitely needs the attribs to be duped, unless we want whatever is being saved to lose its current pointers (bad)
+      def save
+        copy = self.dup
+        copy.attributes = copy.attributes.dup
+        copy.attributes.each do |key,value|
+          copy.attributes[key] = stubify_entities value
+        end
+        SCADS_SERVER.put(self.class.type_name, @primary_key, copy)
+      end
+
+      def delete
+        SCADS_SERVER.remove(self.class.type_name, @primary_key)
+      end
+
+      def index_values(index_name)
+        func = self.class.my_indexes[index_name]
+        if func.class == UnboundMethod
+          func.bind(self).call
+        elsif func.class == Proc
+          func.call(self)
+        else
+          raise "Invalid Index Type #{func.class}"
+        end.map{|k| k + self.primary_key.value.first}
+      end
+
+      #Helper function that allows entities to be serialzed to YAML
+      def to_yaml_type
+        "!scads.eecs.berkeley.edu,2008/#{self.class}"
+      end
+
+      #Helper function that allows entities to be serialzed to YAML
+      def to_yaml_properties
+        ['@primary_key', '@attributes', '@stub'] 
+      end
+
+      protected
+      def self.add_index(name, function, entity_type = self.type_name)
+        (@@indexes[entity_type] ||= {}).merge!({name => function})
+      end
+
+      def stubify_entities item
+        if item.kind_of?(Scads::Entity::Base)
+          # need to dup item too, since we're changing things directly inside it (one layer deep)
+          item = item.dup
+          item.attributes= {}
+          item.stub = true
+        elsif item.kind_of?(Array)
+          item = item.map {|e| stubify_entities e}
+        elsif item.kind_of?(Hash)
+          item.each do |key,value|
+            item[key] = stubify_entities value
+          end
+        end
+        return item
+      end
+
+      def load_stub
+        real = self.class.find(@primary_key)
+        if real.nil?
+          warn "Trying to follow a broken link!"
+          @attributes = {}
+          @stub = false
+        else
+          @attributes = real.attributes
+          @stub = false
+        end
+      end
+    end
+  end
+
+  YAML.add_domain_type( "scads.eecs.berkeley.edu,2008", "" ) do |type, val|
+    type.match( /2008:(\S+)/)[1].split("::").inject(Object) {|o,t| o::const_get(t)}.new(val['primary_key'], val['attributes'], val['stub'])
+  end
+end
\ No newline at end of file
diff --git a/examples/associations.rb b/examples/associations.rb
new file mode 100644
index 0000000..6f10fbd
--- /dev/null
+++ b/examples/associations.rb
@@ -0,0 +1,9 @@
+class Owner < Scads::Entity::Base
+  #Causes the creations of belongs_to_owner index in child
+  has_many :children
+end
+
+class Child < Scads::Entity::Base
+  #Creates method to easily lookup owner
+#  belongs_to :owner
+end
\ No newline at end of file
diff --git a/examples/social.rb b/examples/social.rb
new file mode 100644
index 0000000..0462ad0
--- /dev/null
+++ b/examples/social.rb
@@ -0,0 +1,80 @@
+
+class Profile < Scads::Entity::Base
+  
+  def upcoming_birthday
+   out = Friendship.find_by_friend_of(Storage::Key.new(self, Storage::WildcardCondition.new)).map do |friendship|
+    Storage::Key.new(friendship[:people].select {|f| f != self}.first, self[:birthday])
+   end
+   return out
+  end
+  
+  def to_s
+    self[:name]
+  end
+  
+  indexed_by :upcoming_birthday
+end
+
+class Friendship < Scads::Entity::Base
+  def self.create(f1, f2)
+    f = Friendship.new
+    f[:people] = [f1, f2]
+    return f
+  end
+  
+  def friend_of
+    [
+      Storage::Key.new(self[:people][0], self[:people][1]), 
+      Storage::Key.new(self[:people][1], self[:people][0])
+    ]
+  end
+  
+  def friend_of_friend
+    fof = Array.new # key pairs representing two people who are related as friends of friends
+    self[:people].each_index { |i|
+      # get my friend's index in the people array 
+    	if i.eql?(0) 
+     		iFriend = 1
+    	else
+    		iFriend = 0
+    	end
+    	
+    	searchKey = Storage::Key.new(self[:people][i],Storage::WildcardCondition.new) # wildcard lookup key for friendships involved in
+    	friendships = Friendship.find_by_friend_of(searchKey) # array of direct friendships involved in
+
+    	# for each friendship, make entry in array linking other member to my current friend
+    	friendships.each {|f| 
+    	    	  
+    		# get person whose primary key value is neither mine nor that of my current friend
+    		myKeyVal = self[:people][i].primary_key.value[0] 
+    		friendKeyVal = self[:people][iFriend].primary_key.value[0] 
+    		person = nil # placeholder for potential friend of friend
+    		if !f[:people][0].primary_key.value[0].eql?(myKeyVal) && !f[:people][0].primary_key.value[0].eql?(friendKeyVal) 
+    			person = f[:people][0]
+    		elsif !f[:people][1].primary_key.value[0].eql?(myKeyVal) && !f[:people][1].primary_key.value[0].eql?(friendKeyVal)
+    			person = f[:people][1]
+    		end
+    		
+
+        # if have found a friend of friend, make keys going both directions
+        # first make sure this isn't an existing direct friendship
+    		if !person.nil? 
+    		  existing = Storage::Key.new(self[:people][i],person)
+          if !self.class.find_by_friend_of(existing).empty?
+            next # if direct friendship exists, skip
+          end
+    			fof.push(Storage::Key.new(self[:people][iFriend],person))
+    			fof.push(Storage::Key.new(person,self[:people][iFriend]))
+    		end
+    	}
+    }
+    return fof
+  end
+  
+  def to_s
+    "Friendship: A:  #{self[:people][0]} \t B: #{self[:people][1]}"
+  end
+  
+  indexed_by :friend_of
+  indexed_by :friend_of_friend
+end
diff --git a/init.rb b/init.rb
deleted file mode 100644
index e9b5832..0000000
--- a/init.rb
+++ /dev/null
@@ -1,6 +0,0 @@
-require 'storage/ruby_store'
-require 'server/scads'
-
-Object.const_set(:SCADS_SERVER, Scads::Server::Base.new)
-
-require 'entity/base'
\ No newline at end of file
diff --git a/install.rb b/install.rb
deleted file mode 100644
index e69de29..0000000
diff --git a/lib/entity/associations.rb b/lib/entity/associations.rb
deleted file mode 100644
index 3b3c00e..0000000
--- a/lib/entity/associations.rb
+++ /dev/null
@@ -1,27 +0,0 @@
-require 'active_support'
-
-module Scads
-  module Entity
-    module Associations  
-      def self.included(base)
-        base.extend(ClassMethods)
-      end
-
-      module ClassMethods
-        def has_many(entity_type, field_name = type_name.to_s.downcase)
-          index_name = "belongs_to_#{type_name.to_s.downcase}".intern
-          target = entity_type.to_s.singularize.capitalize.intern
-
-          function = Proc.new do |entity|
-            [entity[field_name.intern].primary_key]
-          end          
-          add_index(index_name, function, target)
-        end
-        
-        def belongs_to(entity_type)
-          #TODO
-        end
-      end
-    end
-  end
-end
\ No newline at end of file
diff --git a/lib/entity/base.rb b/lib/entity/base.rb
deleted file mode 100644
index fec1135..0000000
--- a/lib/entity/base.rb
+++ /dev/null
@@ -1,165 +0,0 @@
-require 'yaml'
-require 'entity/associations'
-
-module Scads
-  module Entity
-    class PrimaryKey
-      @@count = 0
-      def self.new_primary_key
-        Storage::Key.new(@@count = @@count + 1)
-      end
-    end
-
-    class Base
-      include Associations
-
-      attr_writer :attributes, :stub
-      attr_reader :attributes, :stub
-
-      MAX_ROWS = 100
-      @@indexes = {}
-
-      def self.my_indexes
-        @@indexes[type_name] 
-      end
-
-      #Returns the symbol that is registered with the server to refer to entities represented by this class.
-      def self.type_name
-        self.name.split("::").last.intern
-      end
-
-      #Register a new function that generates secondary keys for this Entity Type
-      def self.indexed_by(method_name)
-        add_index(method_name, instance_method(method_name))
-      end
-
-      #Return a list of indexes that have been registered for this entity type
-      def self.index_names
-        return @@indexes[type_name].nil? ? [] : @@indexes[type_name].keys
-      end
-
-      def self.get_class(type_name)
-        Object.const_get(type_name)
-      end
-
-      #Look up and instantiate an entity from the server by primary_key
-      def self.find(primary_key)
-        SCADS_SERVER.get(self.type_name, :primary_table, primary_key, 0 , 0).first
-      end
-
-      def self.method_missing(method_id, *args, &block)
-        unless ((match = method_id.to_s.match(/find_by_(\S+)/)).nil?)
-          index = match[1].intern
-          key = args[0]
-          start_range = args[1] || 0
-          end_range = args[2] || MAX_ROWS
-
-          raise "Invalid Index Specified" unless index_names.member?(index)
-
-          return SCADS_SERVER.get(self.type_name, index, key, start_range, end_range)
-        end
-        raise "Invalid Method #{method_id}"
-      end
-
-      def == other
-        self.primary_key == other.primary_key
-      end
-
-      #Create a new entity
-      def initialize(primary_key = PrimaryKey::new_primary_key, attributes = {}, stub = false)
-        @primary_key = primary_key
-        @attributes = attributes
-        @stub = stub
-      end
-
-      #Returns the primary_key for this entity
-      def primary_key
-        @primary_key
-      end
-
-      def [](attribute_name)
-        load_stub if @stub
-        @attributes[attribute_name]
-      end
-
-      def []=(attribute_name, value)
-        load_stub if @stub
-        @attributes[attribute_name] = value
-      end
-
-      # Store the attributes of this entity to the server.  This will cause any secondary indexes to be recomputed async
-      # anything that might be stubified downstream needs to be duped, at each layer (i think, will have to think more)
-      # definitely needs the attribs to be duped, unless we want whatever is being saved to lose its current pointers (bad)
-      def save
-        copy = self.dup
-        copy.attributes = copy.attributes.dup
-        copy.attributes.each do |key,value|
-          copy.attributes[key] = stubify_entities value
-        end
-        SCADS_SERVER.put(self.class.type_name, @primary_key, copy)
-      end
-
-      def delete
-        SCADS_SERVER.remove(self.class.type_name, @primary_key)
-      end
-
-      def index_values(index_name)
-        func = self.class.my_indexes[index_name]
-        if func.class == UnboundMethod
-          func.bind(self).call
-        elsif func.class == Proc
-          func.call(self)
-        else
-          raise "Invalid Index Type #{func.class}"
-        end.map{|k| k + self.primary_key.value.first}
-      end
-
-      #Helper function that allows entities to be serialzed to YAML
-      def to_yaml_type
-        "!scads.eecs.berkeley.edu,2008/#{self.class}"
-      end
-
-      #Helper function that allows entities to be serialzed to YAML
-      def to_yaml_properties
-        ['@primary_key', '@attributes', '@stub'] 
-      end
-
-      protected
-      def self.add_index(name, function, entity_type = self.type_name)
-        (@@indexes[entity_type] ||= {}).merge!({name => function})
-      end
-
-      def stubify_entities item
-        if item.kind_of?(Scads::Entity::Base)
-          # need to dup item too, since we're changing things directly inside it (one layer deep)
-          item = item.dup
-          item.attributes= {}
-          item.stub = true
-        elsif item.kind_of?(Array)
-          item = item.map {|e| stubify_entities e}
-        elsif item.kind_of?(Hash)
-          item.each do |key,value|
-            item[key] = stubify_entities value
-          end
-        end
-        return item
-      end
-
-      def load_stub
-        real = self.class.find(@primary_key)
-        if real.nil?
-          warn "Trying to follow a broken link!"
-          @attributes = {}
-          @stub = false
-        else
-          @attributes = real.attributes
-          @stub = false
-        end
-      end
-    end
-  end
-
-  YAML.add_domain_type( "scads.eecs.berkeley.edu,2008", "" ) do |type, val|
-    type.match( /2008:(\S+)/)[1].split("::").inject(Object) {|o,t| o::const_get(t)}.new(val['primary_key'], val['attributes'], val['stub'])
-  end
-end
\ No newline at end of file
diff --git a/lib/server/scads.rb b/lib/server/scads.rb
deleted file mode 100644
index 9044f95..0000000
--- a/lib/server/scads.rb
+++ /dev/null
@@ -1,171 +0,0 @@
-require 'server/workqueue'
-
-module Scads
-  module Server
-    class Base
-      attr :entities
-      attr :workqueue
-      attr :lock
-
-      def self.observe(observer, &block)
-        Thread.current[:observer] = observer
-        results = yield
-        Thread.current[:observer] = nil
-        return results
-      end
-
-      def initialize
-        @lock = Mutex.new
-        @entities = {}
-        @workqueue = WorkQueue.new
-      end
-
-      def put(entity_type, entity_id, object)
-        @lock.synchronize do
-          handle_observers @entities[entity_type][:primary_table].store(entity_id, object.to_yaml)
-          object.class.index_names.each do |index|
-            add_to_queue({:entity_type => entity_type, :entity_id => entity_id, :index => index})
-          end
-        end
-        return true
-      end
-
-      # key should be Storage::Key, ex: Key.new(1, GreaterThanCondition(2))
-      def get(entity_type, index_func, key, start, finish)
-        @lock.synchronize do
-          if index_func == :primary_table
-            unless Thread.current[:observer].nil?
-              @entities[entity_type][:primary_table].registerObserver(key, Thread.current[:observer])
-            end
-
-            @entities[entity_type][:primary_table].lookup_range(key, start, finish).map {|o| YAML::load(o[:value])}
-          else
-            # add a wildcard to a keycond since we are accessing an index
-            key += Storage::WildcardCondition.new
-            unless Thread.current[:observer].nil?
-              @entities[entity_type][:indexes][index_func].registerObserver(key, Thread.current[:observer])
-            end
-            # no guarantee we'll get the 'right' result if there was a duplicate and we only asked for 1
-            entity_data = @entities[entity_type][:indexes][index_func].lookup_range(key, start, finish)
-            return entity_data.map do |data|
-              YAML::load(data[:value])
-            end
-          end
-        end
-      end
-
-      def remove(entity_type, entity_id)
-        handle_observers @entities[entity_type][:primary_table].delete(entity_id)
-        @workqueue << remove_index_closure({:entity_type => entity_type, :entity_id => entity_id})
-      end
-
-      #SCADS_SERVER.registerType(self.class.type_name)
-      def registerType(entity_type)
-        @entities[entity_type] = {}
-        # primary_table = (entity_id => data)
-        @entities[entity_type][:primary_table] = Storage::Table.new
-        # second_key_list = (entity_id => [{entity_type, index_func, key},...])
-        @entities[entity_type][:secondary_key_list] = Storage::Table.new
-        @entities[entity_type][:indexes] = {}
-        Entity::Base.get_class(entity_type).index_names.each do |i|
-          @entities[entity_type][:indexes][i] = Storage::Table.new
-        end
-      end
-
-      def to_s
-        out = []
-        out << "############################################################################"
-        out << ""
-        out << "-----------------------------SCADS-SERVER------------------------------"
-        out << "Workqueue: #{@workqueue.size} waiting"
-        out << "Registered Entities:"
-        @entities.each_key do |k|
-          out << "\t" + k.to_s
-        end
-        out << "############################################################################"
-        @entities.each do |k,v|
-          out << "Entity Class: " + k.to_s
-          out << "\tIndexes:"
-          v[:indexes].each_key do |key|
-            out << "\t\t" + key.to_s
-          end
-          out << ""
-          out << "---------------------- Primary Table Contents for " + k.to_s + "------------------"
-          out << v[:primary_table].to_s
-          out << ""
-          out << "\tIndex Contents:"
-          v[:indexes].each do |ik, iv|
-            out << "---------------------- " + ik.to_s + " for " + k.to_s + "------------------"
-            out << iv.to_s
-          end
-          out << ""
-          out << "---------------------- Secondary Key List for " + k.to_s + "------------------"
-          out << v[:secondary_key_list].to_s
-          out << "############################################################################"
-          out << ""
-        end
-        out.join("\n")
-      end
-
-      private
-      def handle_observers(list)
-        list.each do |item|
-          add_to_queue(item)
-        end
-      end
-
-      def add_to_queue(index_def)
-        @workqueue << index_regen_closure(index_def)
-      end
-
-      def remove_index_closure(index_def)
-        Proc.new do
-          entity_type = index_def[:entity_type]
-          entity_id = index_def[:entity_id]
-
-          @entities[entity_type][:secondary_key_list].lookup_range(entity_id + Storage::WildcardCondition.new, 0, 1000).each do |results|
-            YAML::load(results[:value]).each do |key|
-              handle_observers @entities[entity_type][:indexes][results[:key].value[1]].delete(key)
-            end
-            # remove this key from the sec key list
-            @entities[entity_type][:secondary_key_list].delete(results[:key])
-          end
-        end
-      end
-
-      def index_regen_closure(index_def)
-        Proc.new do
-          entity_type = index_def[:entity_type]
-          entity_id = index_def[:entity_id]
-          index = index_def[:index]
-
-          entity = get(entity_type, :primary_table, entity_id, 0,0).first
-          unless entity.nil?
-
-            new_keys = Server::Base.observe(index_def) do
-              entity.index_values(index)
-            end
-            @lock.synchronize do
-              old_keys = entities[entity_type][:secondary_key_list].lookup_range(entity_id + index, 0, 0).map do |r|
-                YAML::load(r[:value])
-              end.flatten || []
-
-              to_delete = old_keys.select {|key| !new_keys.member?(key)}
-              to_add = new_keys.select{|key| !old_keys.member?(key)}
-
-              entities[entity_type][:secondary_key_list].store(entity_id + index, new_keys.to_yaml)
-
-              to_delete.each do |key|
-                entities[entity_type][:indexes][index].delete(key).each {|o| @workqueue << index_regen_closure(o)}
-              end
-
-              to_add.each do |key|
-                entities[entity_type][:indexes][index].store(key, entity.to_yaml).each {|o| @workqueue << index_regen_closure(o)}
-              end
-            end
-          end
-        end
-      end
-    end
-  end
-end
\ No newline at end of file
diff --git a/lib/server/workqueue.rb b/lib/server/workqueue.rb
deleted file mode 100644
index 91bd626..0000000
--- a/lib/server/workqueue.rb
+++ /dev/null
@@ -1,35 +0,0 @@
-require 'rubygems'
-require 'fastthread'
-
-class WorkQueue < Queue
-  attr :lock
-
-  Thread.abort_on_exception = true
-  def initialize
-    @lock = Mutex.new
-    @in_progress = 0
-    @worker = Thread.new do
-      while(true)
-        deq.call
-        @lock.synchronize do
-          @in_progress -= 1
-        end
-      end
-    end
-  end
-
-  def << (obj)
-    @lock.synchronize do
-      @in_progress += 1
-    end
-    push(obj)
-  end
-
-  def clean
-    while true
-      @lock.synchronize do
-        return if @in_progress == 0
-      end
-    end
-  end
-end
\ No newline at end of file
diff --git a/lib/storage/bdb_store.rb b/lib/storage/bdb_store.rb
deleted file mode 100644
index 10ddb34..0000000
--- a/lib/storage/bdb_store.rb
+++ /dev/null
@@ -1,249 +0,0 @@
-require 'bdb'
-require 'yaml'
-require 'rubygems'
-require 'ruby-debug'
-
-module Storage
-  class Table
-
-    @@DB_FILE_NAME = "tmp/scads.db"
-    @@BDB_OBJECT = BDB::Btree.new(@@DB_FILE_NAME, 'global', BDB::CREATE || BDB::TRUNCATE)
-
-    def initialize
-      @db_name = Time.now.to_f.to_s
-      @db = BDB::Btree.open(@@DB_FILE_NAME, @db_name, BDB::CREATE)
-      @observerlist = Hash.new;
-    end
-
-    def store(key, value)
-      raise unless (value.class == String)
-      observers = relevant_observers(key)
-      @db[key.bdb_key] = {:key => key, :value => value}.to_yaml
-      return (observers || [])
-    end
-
-    def delete(key)
-      observers = relevant_observers(key)
-      @db.delete(key.bdb_key)
-      return (observers || [])
-    end
-
-    def lookup_range(keycondition,start,numresults)
-      range = @db.cursor
-      firstpair =  range.get(BDB::SET_RANGE,keycondition.bdb_key)
-      return [] unless firstpair
-      (results = []) << YAML::load(firstpair[1])
-      (start+numresults).times do
-        if (next_obj = range.next) then results << YAML::load(next_obj[1]) end
-        end
-        (results[start..start+numresults] || []).select do |hash|
-          (keycondition <=> hash[:key]) == 0
-        end 
-      end
-
-      def registerObserver(keyCondition, function)
-        hashkey = keyCondition
-        # need to match key conditions via their == method
-        @observerlist.each_key do |keycond|
-          if keyCondition == keycond
-            hashkey = keycond
-            break
-          end
-        end
-        @observerlist[hashkey] ||= []
-        # don't accept duplicate functions
-        #puts "adding #{hashkey} => #{function.to_s} to the observerlist" unless @observerlist[hashkey].include? function
-        @observerlist[hashkey] << function unless @observerlist[hashkey].include? function
-      end
-
-      def to_s
-        out = "*** Table ***\n"
-        @datahash.to_a.sort_by{|x| x.first}.each do |pair|
-          out << key_to_string(pair.first) + "\t=>\t" + (YAML::load pair[1]).to_s + "\n"
-        end
-        out << "*** Observers ***\tKey\t\tFunction\t\tEntity\n"
-        @observerlist.to_a.sort_by{|x| x.first}.each do |pair|
-          # pair[1] is a list of hashes, one per func registered on the key pair.first
-          out << pair.first.to_s + "\t=>\t" 
-          pair[1].each_with_index do |f,i|
-            out << "\t\t\t" unless i == 0
-            f.each_value {|v| out << v.to_s + "\t"}
-            out << "\n"
-          end
-        end
-        out
-      end
-
-      def key_to_string(keyval)
-        "<key: " + (keyval.map {|x| x.to_s}.join ',') + ">"
-      end
-
-      private
-
-      # removing observers here, since they really are just a one-time use
-      def relevant_observers(key)
-        observers = []
-        @observerlist.each_pair do |keycond, obslist|
-          if keycond == key
-            observers += obslist
-            #puts "trying to remove " + keycond.to_s + " from the observerlist"
-            @observerlist.delete(keycond)
-          end
-        end
-        return observers
-      end
-
-
-    end
-
-    class Key 
-
-      @@unitlength = 32
-
-      def self.blank_str
-        "1" + ("0" * (@@unitlength - 1))
-      end
-
-      include Comparable
-
-      attr_reader :keytuple
-
-      def size
-        @keytuple.length
-      end
-
-      def self.valid_type?(value)
-        valid_classes = [Fixnum, Symbol, String]
-        return valid_classes.member?(value.class)
-      end
-
-      def initialize(*key)
-        @keytuple = key.map do |key_part|
-          if Key::valid_type?(key_part)
-            EqualityCondition.new(key_part)
-          elsif(key_part.class.superclass == KeyCondition)
-            key_part
-          elsif(key_part.class.superclass == Scads::Entity::Base)
-            EqualityCondition.new(key_part.primary_key.value[0])
-          else
-            raise "#{key_part.class} is not a valid key_part type"
-          end
-        end
-      end
-
-      def to_s
-        "<key: " + (@keytuple.map {|x| x.to_s}.join ',') + ">"
-      end
-
-      def bdb_key
-        raise "key length is too long" unless @keytuple.all? { |keystr| keystr.bdb_key.length < @@unitlength}
-        @keytuple.map {|keyval| keyval.bdb_key.rjust(@@unitlength,"0")}.join '^'
-      end
-
-      def +(new_key)
-        Key.new(*(@keytuple + [new_key]))
-      end
-
-      def ==(other)
-        (self <=> other) == 0
-      end
-
-      def <=> other
-        raise "Wrong Arities" if @keytuple.size != other.keytuple.size
-        compare_helper @keytuple.dup, other.keytuple.dup      
-      end
-
-      def value
-        @keytuple.map {|k| k.value}
-      end
-
-      def compare_helper(keytup1, keytup2)
-        return 0 if keytup1.empty?
-        firstcomparison = keytup1.shift <=> keytup2.shift
-        return firstcomparison unless firstcomparison == 0
-        return compare_helper(keytup1,keytup2)
-      end
-
-    end
-
-    class KeyCondition    
-      def <=>
-        raise 'Unimplemented'
-      end
-
-      def value
-        raise 'Invalid'
-      end
-    end
-
-    class EqualityCondition < KeyCondition
-      def initialize(value)
-        raise "Invalid Type" unless Key::valid_type?(value)
-        @value = value
-      end
-
-      def <=>(other)
-        @value <=> other.value
-      end
-
-      def value
-        @value
-      end
-
-      def to_s
-        "==" + @value.to_s
-      end
-
-      def bdb_key
-        @value.to_s
-      end
-
-    end
-
-    class GreaterThanCondition < KeyCondition
-      def initialize(value)
-        raise "Invalid Type" unless Key::valid_type?(value)
-        @value = value
-      end
-
-      def <=>(other)
-        @value < other.value ? 0 : 1
-      end
-
-      def to_s
-        ">" + @value.to_s
-      end
-
-      def bdb_key
-        @value.to_s
-      end
-
-    end
-
-    class WildcardCondition < KeyCondition
-      def <=>(other)
-        0
-      end
-
-      def to_s
-        "*"
-      end
-
-      def bdb_key
-        ""
-      end
-
-    end
-
-  end
-
-  class Symbol
-    def <=> other
-      self.to_s <=> other.to_s
-    end
-
-    def to_proc
-      Proc.new { |*args| args.shift.send(self, *args) }
-    end
-
-  end
diff --git a/lib/storage/ruby_store.rb b/lib/storage/ruby_store.rb
deleted file mode 100644
index aee432c..0000000
--- a/lib/storage/ruby_store.rb
+++ /dev/null
@@ -1,233 +0,0 @@
-module Storage
-  class Table
-
-    attr_accessor :datahash
-
-    def initialize
-      @datahash = Hash.new;
-      @observerlist = Hash.new;
-      @lock = Mutex.new
-    end
-
-    #returns list of observers
-    def store(key, value)
-      @lock.synchronize do
-        raise unless (value.class == String)
-        observers = relevant_observers(key)
-        @datahash[key.value] = value
-        return (observers || [])
-      end
-    end
-
-    #returns list of observers
-    def delete(key)
-      @lock.synchronize do
-        observers = relevant_observers(key)
-        @datahash.delete key.value
-        return (observers || [])
-      end
-    end
-
-    def lookup_range(keycondition,start,numresults)
-      @lock.synchronize do
-        results = 
-        @datahash.keys.select do |key|
-          (keycondition <=> Key.new(*key)) == 0 
-        end.map do |key| 
-          {:key => Key.new(*key), :value => @datahash[key]}
-        end[start..(start+numresults)]
-        (results ||= [])
-        results.sort_by {|x| x[:key]}
-      end
-    end
-
-    def registerObserver(keyCondition, function)
-      hashkey = keyCondition
-      # need to match key conditions via their == method
-      @observerlist.each_key do |keycond|
-        if keyCondition == keycond
-          hashkey = keycond
-          break
-        end
-      end
-      @observerlist[hashkey] ||= []
-      # don't accept duplicate functions
-      #puts "adding #{hashkey} => #{function.to_s} to the observerlist" unless @observerlist[hashkey].include? function
-      @observerlist[hashkey] << function unless @observerlist[hashkey].include? function
-    end
-
-    def to_s
-      out = "*** Table ***\n"
-      @datahash.to_a.sort_by{|x| x.first}.each do |pair|
-        out << key_to_string(pair.first) + "\t=>\t" + (YAML::load pair[1]).to_s + "\n"
-      end
-      out << "*** Observers ***\tKey\t\tFunction\t\tEntity\n"
-      @observerlist.to_a.sort_by{|x| x.first}.each do |pair|
-        # pair[1] is a list of hashes, one per func registered on the key pair.first
-        out << pair.first.to_s + "\t=>\t" 
-        pair[1].each_with_index do |f,i|
-          out << "\t\t\t" unless i == 0
-          f.each_value {|v| out << v.to_s + "\t"}
-          out << "\n"
-        end
-      end
-      out
-    end
-
-    def key_to_string(keyval)
-      "<key: " + (keyval.map {|x| x.to_s}.join ',') + ">"
-    end
-
-    private
-
-    # removing observers here, since they really are just a one-time use
-    def relevant_observers(key)
-      observers = []
-      @observerlist.each_pair do |keycond, obslist|
-        if keycond == key
-          observers += obslist
-          #puts "trying to remove " + keycond.to_s + " from the observerlist"
-          @observerlist.delete(keycond)
-        end
-      end
-      return observers
-    end
-
-
-  end
-
-  class Key 
-    include Comparable
-
-    attr_reader :keytuple
-
-    def size
-      @keytuple.length
-    end
-
-    def self.valid_type?(value)
-      if value.class == Fixnum
-        return true
-      end
-      if value.class == Symbol
-        return true
-      end
-      if value.class == String
-        return true
-      end
-      return false
-    end
-
-    def initialize(*key)
-      @keytuple = key.map do |key_part|
-        if Key::valid_type?(key_part)
-          EqualityCondition.new(key_part)
-        elsif(key_part.class.superclass == KeyCondition)
-          key_part
-        elsif(key_part.class.superclass == Scads::Entity::Base)
-          EqualityCondition.new(key_part.primary_key.value[0])
-        else
-          raise "#{key_part.class} is not a valid key_part type"
-        end
-      end
-    end
-
-    def to_s
-      "<key: " + (@keytuple.map {|x| x.to_s}.join ',') + ">"
-    end
-
-    def +(new_key)
-      Key.new(*(@keytuple + [new_key]))
-    end
-
-    def ==(other)
-      (self <=> other) == 0
-    end
-
-    def <=> other
-      raise "Wrong Arities" if @keytuple.size != other.keytuple.size
-      compare_helper @keytuple.dup, other.keytuple.dup      
-    end
-
-    def value
-      @keytuple.map {|k| k.value}
-    end
-
-    def compare_helper(keytup1, keytup2)
-      return 0 if keytup1.empty?
-      firstcomparison = keytup1.shift <=> keytup2.shift
-      return firstcomparison unless firstcomparison == 0
-      return compare_helper(keytup1,keytup2)
-    end
-  end
-
-  class KeyCondition    
-    def <=>
-      raise 'Unimplemented'
-    end
-
-    def value
-      raise 'Invalid'
-    end
-  end
-
-  class EqualityCondition < KeyCondition
-    def initialize(value)
-      raise "Invalid Type" unless Key::valid_type?(value)
-      @value = value
-    end
-
-    def <=>(other)
-      @value <=> other.value
-    end
-
-    def value
-      @value
-    end
-
-    def to_s
-      "==" + @value.to_s
-    end
-
-  end
-
-  class GreaterThanCondition < KeyCondition
-    def initialize(value)
-      raise "Invalid Type" unless Key::valid_type?(value)
-      @value = value
-    end
-
-    def <=>(other)
-      @value < other.value ? 0 : 1
-    end
-
-    def to_s
-      ">" + @value.to_s
-    end
-  end
-
-  class WildcardCondition < KeyCondition
-    def <=>(other)
-      0
-    end
-
-    def to_s
-      "*"
-    end
-
-  end
-
-end
-
-class Symbol
-  def <=> other
-    self.to_s <=> other.to_s
-  end
-
-  # def to_proc
-  #   proc { |obj, *args| obj.send(self, *args) }
-  # end
-
-end
-
-
diff --git a/server/scads.rb b/server/scads.rb
new file mode 100644
index 0000000..6780844
--- /dev/null
+++ b/server/scads.rb
@@ -0,0 +1,169 @@
+require 'server/workqueue'
+
+module Scads
+  module Server
+    class Base
+      attr :entities
+      attr :workqueue
+      attr :lock
+
+      def self.observe(observer, &block)
+        Thread.current[:observer] = observer
+        results = yield
+        Thread.current[:observer] = nil
+        return results
+      end
+
+      def initialize
+        @lock = Mutex.new
+        @entities = {}
+        @workqueue = WorkQueue.new
+      end
+
+      def put(entity_type, entity_id, object)
+        @lock.synchronize do
+          handle_observers @entities[entity_type][:primary_table].store(entity_id, object.to_yaml)
+          object.class.index_names.each do |index|
+            add_to_queue({:entity_type => entity_type, :entity_id => entity_id, :index => index})
+          end
+        end
+        return true
+      end
+
+      # key should be Storage::Key, ex: Key.new(1, GreaterThanCondition(2))
+      def get(entity_type, index_func, key, start, finish)
+        @lock.synchronize do
+          if index_func == :primary_table
+            unless Thread.current[:observer].nil?
+              @entities[entity_type][:primary_table].registerObserver(key, Thread.current[:observer])
+            end
+
+            @entities[entity_type][:primary_table].lookup_range(key, start, finish).map {|o| YAML::load(o[:value])}
+          else
+            # add a wildcard to a keycond since we are accessing an index
+            key += Storage::WildcardCondition.new
+            unless Thread.current[:observer].nil?
+              @entities[entity_type][:indexes][index_func].registerObserver(key, Thread.current[:observer])
+            end
+            # no guarantee we'll get the 'right' result if there was a duplicate and we only asked for 1
+            entity_data = @entities[entity_type][:indexes][index_func].lookup_range(key, start, finish)
+            return entity_data.map do |data|
+              YAML::load(data[:value])
+            end
+          end
+        end
+      end
+
+      def remove(entity_type, entity_id)
+        handle_observers @entities[entity_type][:primary_table].delete(entity_id)
+        @workqueue << remove_index_closure({:entity_type => entity_type, :entity_id => entity_id})
+      end
+
+      #SCADS_SERVER.registerType(self.class.type_name)
+      def registerType(entity_type)
+        @entities[entity_type] = {}
+        # primary_table = (entity_id => data)
+        @entities[entity_type][:primary_table] = Storage::Table.new
+        # second_key_list = (entity_id => [{entity_type, index_func, key},...])
+        @entities[entity_type][:secondary_key_list] = Storage::Table.new
+        @entities[entity_type][:indexes] = {}
+        Entity::Base.get_class(entity_type).index_names.each do |i|
+          @entities[entity_type][:indexes][i] = Storage::Table.new
+        end
+      end
+
+      def to_s
+        puts "############################################################################"
+        puts ""
+        puts "-----------------------------SCADS-SERVER------------------------------"
+        puts "Workqueue: #{@workqueue.size} waiting"
+        puts "Registered Entities:"
+        @entities.each_key do |k|
+          puts "\t" + k.to_s
+        end
+        puts "############################################################################"
+        @entities.each do |k,v|
+          puts "Entity Class: " + k.to_s
+          puts "\tIndexes:"
+          v[:indexes].each_key do |key|
+            puts "\t\t" + key.to_s
+          end
+          puts ""
+          puts "---------------------- Primary Table Contents for " + k.to_s + "------------------"
+          puts v[:primary_table].to_s
+          puts ""
+          puts "\tIndex Contents:"
+          v[:indexes].each do |ik, iv|
+            puts "---------------------- " + ik.to_s + " for " + k.to_s + "------------------"
+            puts iv.to_s
+          end
+          puts ""
+          puts "---------------------- Secondary Key List for " + k.to_s + "------------------"
+          puts v[:secondary_key_list].to_s
+          puts "############################################################################"
+          puts ""
+        end
+      end
+
+      private
+      def handle_observers(list)
+        list.each do |item|
+          add_to_queue(item)
+        end
+      end
+
+      def add_to_queue(index_def)
+        @workqueue << index_regen_closure(index_def)
+      end
+
+      def remove_index_closure(index_def)
+        Proc.new do
+          entity_type = index_def[:entity_type]
+          entity_id = index_def[:entity_id]
+
+          @entities[entity_type][:secondary_key_list].lookup_range(entity_id + Storage::WildcardCondition.new, 0, 1000).each do |results|
+            YAML::load(results[:value]).each do |key|
+              handle_observers @entities[entity_type][:indexes][results[:key].value[1]].delete(key)
+            end
+            # remove this key from the sec key list
+            @entities[entity_type][:secondary_key_list].delete(results[:key])
+          end
+        end
+      end
+
+      def index_regen_closure(index_def)
+        Proc.new do
+          entity_type = index_def[:entity_type]
+          entity_id = index_def[:entity_id]
+          index = index_def[:index]
+
+          entity = get(entity_type, :primary_table, entity_id, 0,0).first
+          unless entity.nil?
+
+            new_keys = Server::Base.observe(index_def) do
+              entity.index_values(index)
+            end
+            @lock.synchronize do
+              old_keys = entities[entity_type][:secondary_key_list].lookup_range(entity_id + index, 0, 0).map do |r|
+                YAML::load(r[:value])
+              end.flatten || []
+
+              to_delete = old_keys.select {|key| !new_keys.member?(key)}
+              to_add = new_keys.select{|key| !old_keys.member?(key)}
+
+              entities[entity_type][:secondary_key_list].store(entity_id + index, new_keys.to_yaml)
+
+              to_delete.each do |key|
+                entities[entity_type][:indexes][index].delete(key).each {|o| @workqueue << index_regen_closure(o)}
+              end
+
+              to_add.each do |key|
+                entities[entity_type][:indexes][index].store(key, entity.to_yaml).each {|o| @workqueue << index_regen_closure(o)}
+              end
+            end
+          end
+        end
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/server/workqueue.rb b/server/workqueue.rb
new file mode 100644
index 0000000..91bd626
--- /dev/null
+++ b/server/workqueue.rb
@@ -0,0 +1,35 @@
+require 'rubygems'
+require 'fastthread'
+
+class WorkQueue < Queue
+  attr :lock
+
+  Thread.abort_on_exception = true
+  def initialize
+    @lock = Mutex.new
+    @in_progress = 0
+    @worker = Thread.new do
+      while(true)
+        deq.call
+        @lock.synchronize do
+          @in_progress -= 1
+        end
+      end
+    end
+  end
+
+  def << (obj)
+    @lock.synchronize do
+      @in_progress += 1
+    end
+    push(obj)
+  end
+
+  def clean
+    while true
+      @lock.synchronize do
+        return if @in_progress == 0
+      end
+    end
+  end
+end
\ No newline at end of file
diff --git a/storage/bdb_store.rb b/storage/bdb_store.rb
new file mode 100644
index 0000000..10ddb34
--- /dev/null
+++ b/storage/bdb_store.rb
@@ -0,0 +1,249 @@
+require 'bdb'
+require 'yaml'
+require 'rubygems'
+require 'ruby-debug'
+
+module Storage
+  class Table
+
+    @@DB_FILE_NAME = "tmp/scads.db"
+    @@BDB_OBJECT = BDB::Btree.new(@@DB_FILE_NAME, 'global', BDB::CREATE || BDB::TRUNCATE)
+
+    def initialize
+      @db_name = Time.now.to_f.to_s
+      @db = BDB::Btree.open(@@DB_FILE_NAME, @db_name, BDB::CREATE)
+      @observerlist = Hash.new;
+    end
+
+    def store(key, value)
+      raise unless (value.class == String)
+      observers = relevant_observers(key)
+      @db[key.bdb_key] = {:key => key, :value => value}.to_yaml
+      return (observers || [])
+    end
+
+    def delete(key)
+      observers = relevant_observers(key)
+      @db.delete(key.bdb_key)
+      return (observers || [])
+    end
+
+    def lookup_range(keycondition,start,numresults)
+      range = @db.cursor
+      firstpair =  range.get(BDB::SET_RANGE,keycondition.bdb_key)
+      return [] unless firstpair
+      (results = []) << YAML::load(firstpair[1])
+      (start+numresults).times do
+        if (next_obj = range.next) then results << YAML::load(next_obj[1]) end
+        end
+        (results[start..start+numresults] || []).select do |hash|
+          (keycondition <=> hash[:key]) == 0
+        end 
+      end
+
+      def registerObserver(keyCondition, function)
+        hashkey = keyCondition
+        # need to match key conditions via their == method
+        @observerlist.each_key do |keycond|
+          if keyCondition == keycond
+            hashkey = keycond
+            break
+          end
+        end
+        @observerlist[hashkey] ||= []
+        # don't accept duplicate functions
+        #puts "adding #{hashkey} => #{function.to_s} to the observerlist" unless @observerlist[hashkey].include? function
+        @observerlist[hashkey] << function unless @observerlist[hashkey].include? function
+      end
+
+      def to_s
+        out = "*** Table ***\n"
+        @datahash.to_a.sort_by{|x| x.first}.each do |pair|
+          out << key_to_string(pair.first) + "\t=>\t" + (YAML::load pair[1]).to_s + "\n"
+        end
+        out << "*** Observers ***\tKey\t\tFunction\t\tEntity\n"
+        @observerlist.to_a.sort_by{|x| x.first}.each do |pair|
+          # pair[1] is a list of hashes, one per func registered on the key pair.first
+          out << pair.first.to_s + "\t=>\t" 
+          pair[1].each_with_index do |f,i|
+            out << "\t\t\t" unless i == 0
+            f.each_value {|v| out << v.to_s + "\t"}
+            out << "\n"
+          end
+        end
+        out
+      end
+
+      def key_to_string(keyval)
+        "<key: " + (keyval.map {|x| x.to_s}.join ',') + ">"
+      end
+
+      private
+
+      # removing observers here, since they really are just a one-time use
+      def relevant_observers(key)
+        observers = []
+        @observerlist.each_pair do |keycond, obslist|
+          if keycond == key
+            observers += obslist
+            #puts "trying to remove " + keycond.to_s + " from the observerlist"
+            @observerlist.delete(keycond)
+          end
+        end
+        return observers
+      end
+
+
+    end
+
+    class Key 
+
+      @@unitlength = 32
+
+      def self.blank_str
+        "1" + ("0" * (@@unitlength - 1))
+      end
+
+      include Comparable
+
+      attr_reader :keytuple
+
+      def size
+        @keytuple.length
+      end
+
+      def self.valid_type?(value)
+        valid_classes = [Fixnum, Symbol, String]
+        return valid_classes.member?(value.class)
+      end
+
+      def initialize(*key)
+        @keytuple = key.map do |key_part|
+          if Key::valid_type?(key_part)
+            EqualityCondition.new(key_part)
+          elsif(key_part.class.superclass == KeyCondition)
+            key_part
+          elsif(key_part.class.superclass == Scads::Entity::Base)
+            EqualityCondition.new(key_part.primary_key.value[0])
+          else
+            raise "#{key_part.class} is not a valid key_part type"
+          end
+        end
+      end
+
+      def to_s
+        "<key: " + (@keytuple.map {|x| x.to_s}.join ',') + ">"
+      end
+
+      def bdb_key
+        raise "key length is too long" unless @keytuple.all? { |keystr| keystr.bdb_key.length < @@unitlength}
+        @keytuple.map {|keyval| keyval.bdb_key.rjust(@@unitlength,"0")}.join '^'
+      end
+
+      def +(new_key)
+        Key.new(*(@keytuple + [new_key]))
+      end
+
+      def ==(other)
+        (self <=> other) == 0
+      end
+
+      def <=> other
+        raise "Wrong Arities" if @keytuple.size != other.keytuple.size
+        compare_helper @keytuple.dup, other.keytuple.dup      
+      end
+
+      def value
+        @keytuple.map {|k| k.value}
+      end
+
+      def compare_helper(keytup1, keytup2)
+        return 0 if keytup1.empty?
+        firstcomparison = keytup1.shift <=> keytup2.shift
+        return firstcomparison unless firstcomparison == 0
+        return compare_helper(keytup1,keytup2)
+      end
+
+    end
+
+    class KeyCondition    
+      def <=>
+        raise 'Unimplemented'
+      end
+
+      def value
+        raise 'Invalid'
+      end
+    end
+
+    class EqualityCondition < KeyCondition
+      def initialize(value)
+        raise "Invalid Type" unless Key::valid_type?(value)
+        @value = value
+      end
+
+      def <=>(other)
+        @value <=> other.value
+      end
+
+      def value
+        @value
+      end
+
+      def to_s
+        "==" + @value.to_s
+      end
+
+      def bdb_key
+        @value.to_s
+      end
+
+    end
+
+    class GreaterThanCondition < KeyCondition
+      def initialize(value)
+        raise "Invalid Type" unless Key::valid_type?(value)
+        @value = value
+      end
+
+      def <=>(other)
+        @value < other.value ? 0 : 1
+      end
+
+      def to_s
+        ">" + @value.to_s
+      end
+
+      def bdb_key
+        @value.to_s
+      end
+
+    end
+
+    class WildcardCondition < KeyCondition
+      def <=>(other)
+        0
+      end
+
+      def to_s
+        "*"
+      end
+
+      def bdb_key
+        ""
+      end
+
+    end
+
+  end
+
+  class Symbol
+    def <=> other
+      self.to_s <=> other.to_s
+    end
+
+    def to_proc
+      Proc.new { |*args| args.shift.send(self, *args) }
+    end
+
+  end
diff --git a/storage/ruby_store.rb b/storage/ruby_store.rb
new file mode 100644
index 0000000..aee432c
--- /dev/null
+++ b/storage/ruby_store.rb
@@ -0,0 +1,233 @@
+module Storage
+  class Table
+
+    attr_accessor :datahash
+
+    def initialize
+      @datahash = Hash.new;
+      @observerlist = Hash.new;
+      @lock = Mutex.new
+    end
+
+    #returns list of observers
+    def store(key, value)
+      @lock.synchronize do
+        raise unless (value.class == String)
+        observers = relevant_observers(key)
+        @datahash[key.value] = value
+        return (observers || [])
+      end
+    end
+
+    #returns list of observers
+    def delete(key)
+      @lock.synchronize do
+        observers = relevant_observers(key)
+        @datahash.delete key.value
+        return (observers || [])
+      end
+    end
+
+    def lookup_range(keycondition,start,numresults)
+      @lock.synchronize do
+        results = 
+        @datahash.keys.select do |key|
+          (keycondition <=> Key.new(*key)) == 0 
+        end.map do |key| 
+          {:key => Key.new(*key), :value => @datahash[key]}
+        end[start..(start+numresults)]
+        (results ||= [])
+        results.sort_by {|x| x[:key]}
+      end
+    end
+
+    def registerObserver(keyCondition, function)
+      hashkey = keyCondition
+      # need to match key conditions via their == method
+      @observerlist.each_key do |keycond|
+        if keyCondition == keycond
+          hashkey = keycond
+          break
+        end
+      end
+      @observerlist[hashkey] ||= []
+      # don't accept duplicate functions
+      #puts "adding #{hashkey} => #{function.to_s} to the observerlist" unless @observerlist[hashkey].include? function
+      @observerlist[hashkey] << function unless @observerlist[hashkey].include? function
+    end
+
+    def to_s
+      out = "*** Table ***\n"
+      @datahash.to_a.sort_by{|x| x.first}.each do |pair|
+        out << key_to_string(pair.first) + "\t=>\t" + (YAML::load pair[1]).to_s + "\n"
+      end
+      out << "*** Observers ***\tKey\t\tFunction\t\tEntity\n"
+      @observerlist.to_a.sort_by{|x| x.first}.each do |pair|
+        # pair[1] is a list of hashes, one per func registered on the key pair.first
+        out << pair.first.to_s + "\t=>\t" 
+        pair[1].each_with_index do |f,i|
+          out << "\t\t\t" unless i == 0
+          f.each_value {|v| out << v.to_s + "\t"}
+          out << "\n"
+        end
+      end
+      out
+    end
+
+    def key_to_string(keyval)
+      "<key: " + (keyval.map {|x| x.to_s}.join ',') + ">"
+    end
+
+    private
+
+    # removing observers here, since they really are just a one-time use
+    def relevant_observers(key)
+      observers = []
+      @observerlist.each_pair do |keycond, obslist|
+        if keycond == key
+          observers += obslist
+          #puts "trying to remove " + keycond.to_s + " from the observerlist"
+          @observerlist.delete(keycond)
+        end
+      end
+      return observers
+    end
+
+
+  end
+
+  class Key 
+    include Comparable
+
+    attr_reader :keytuple
+
+    def size
+      @keytuple.length
+    end
+
+    def self.valid_type?(value)
+      if value.class == Fixnum
+        return true
+      end
+      if value.class == Symbol
+        return true
+      end
+      if value.class == String
+        return true
+      end
+      return false
+    end
+
+    def initialize(*key)
+      @keytuple = key.map do |key_part|
+        if Key::valid_type?(key_part)
+          EqualityCondition.new(key_part)
+        elsif(key_part.class.superclass == KeyCondition)
+          key_part
+        elsif(key_part.class.superclass == Scads::Entity::Base)
+          EqualityCondition.new(key_part.primary_key.value[0])
+        else
+          raise "#{key_part.class} is not a valid key_part type"
+        end
+      end
+    end
+
+    def to_s
+      "<key: " + (@keytuple.map {|x| x.to_s}.join ',') + ">"
+    end
+
+    def +(new_key)
+      Key.new(*(@keytuple + [new_key]))
+    end
+
+    def ==(other)
+      (self <=> other) == 0
+    end
+
+    def <=> other
+      raise "Wrong Arities" if @keytuple.size != other.keytuple.size
+      compare_helper @keytuple.dup, other.keytuple.dup      
+    end
+
+    def value
+      @keytuple.map {|k| k.value}
+    end
+
+    def compare_helper(keytup1, keytup2)
+      return 0 if keytup1.empty?
+      firstcomparison = keytup1.shift <=> keytup2.shift
+      return firstcomparison unless firstcomparison == 0
+      return compare_helper(keytup1,keytup2)
+    end
+  end
+
+  class KeyCondition    
+    def <=>
+      raise 'Unimplemented'
+    end
+
+    def value
+      raise 'Invalid'
+    end
+  end
+
+  class EqualityCondition < KeyCondition
+    def initialize(value)
+      raise "Invalid Type" unless Key::valid_type?(value)
+      @value = value
+    end
+
+    def <=>(other)
+      @value <=> other.value
+    end
+
+    def value
+      @value
+    end
+
+    def to_s
+      "==" + @value.to_s
+    end
+
+  end
+
+  class GreaterThanCondition < KeyCondition
+    def initialize(value)
+      raise "Invalid Type" unless Key::valid_type?(value)
+      @value = value
+    end
+
+    def <=>(other)
+      @value < other.value ? 0 : 1
+    end
+
+    def to_s
+      ">" + @value.to_s
+    end
+  end
+
+  class WildcardCondition < KeyCondition
+    def <=>(other)
+      0
+    end
+
+    def to_s
+      "*"
+    end
+
+  end
+
+end
+
+class Symbol
+  def <=> other
+    self.to_s <=> other.to_s
+  end
+
+  # def to_proc
+  #   proc { |obj, *args| obj.send(self, *args) }
+  # end
+
+end
+
+
diff --git a/test/all_bdb.rb b/test/all_bdb.rb
index ef7b9df..de8b006 100644
--- a/test/all_bdb.rb
+++ b/test/all_bdb.rb
@@ -1,6 +1,3 @@
-$:.push('./lib/')
-$:.push('./test/')
-
 require 'rubygems'
 
 require 'storage/bdb_store'
diff --git a/test/all_ruby.rb b/test/all_ruby.rb
index e109fd3..4bed9f3 100644
--- a/test/all_ruby.rb
+++ b/test/all_ruby.rb
@@ -1,6 +1,3 @@
-$:.push('./lib/')
-$:.push('./test/')
-
 require 'rubygems'
 
 require 'storage/ruby_store'
diff --git a/test/examples/associations.rb b/test/examples/associations.rb
deleted file mode 100644
index 6f10fbd..0000000
--- a/test/examples/associations.rb
+++ /dev/null
@@ -1,9 +0,0 @@
-class Owner < Scads::Entity::Base
-  #Causes the creations of belongs_to_owner index in child
-  has_many :children
-end
-
-class Child < Scads::Entity::Base
-  #Creates method to easily lookup owner
-#  belongs_to :owner
-end
\ No newline at end of file
diff --git a/test/examples/db.rb b/test/examples/db.rb
deleted file mode 100644
index 0f8b6e3..0000000
--- a/test/examples/db.rb
+++ /dev/null
@@ -1,34 +0,0 @@
-require 'scads.rb'
-require 'examples/social.rb'
-
-#profiles = []
-#
-#(0..9).each do |val|
-#  p = Profile.new
-#  p[:birthday] = rand 1000
-#  p[:name] = "person" + val.to_s
-#  p.save
-#  profiles << p
-#end
-#
-#profiles.each_with_index do |prof1,ind1|
-#  profiles.each_with_index do |prof2,ind2|
-#    if (rand 6) == 1 && (ind1 > ind2)
-#      f = Friendship.create(prof1,prof2)
-#      f.save
-#    end
-#  end
-#end
-
-p1 = Profile.new
-p2 = Profile.new
-p1[:birthday] = "jan1"
-p2[:birthday] = "july14"
-p1[:name] = "barret"
-p2[:name] = "jake"
-p1.save
-p2.save
-f = Friendship.create(p1,p2)
-f.save
-
-print SCADS_SERVER
diff --git a/test/examples/social.rb b/test/examples/social.rb
deleted file mode 100644
index 7f37ecb..0000000
--- a/test/examples/social.rb
+++ /dev/null
@@ -1,37 +0,0 @@
-
-class Profile < Scads::Entity::Base
-  
-  def upcoming_birthday
-   out = Friendship.find_by_friend_of(Storage::Key.new(self, Storage::WildcardCondition.new)).map do |friendship|
-    Storage::Key.new(friendship[:people].select {|f| f != self}.first, self[:birthday])
-   end
-   return out
-  end
-  
-  def to_s
-    self[:name]
-  end
-  
-  indexed_by :upcoming_birthday
-end
-
-class Friendship < Scads::Entity::Base
-  def self.create(f1, f2)
-    f = Friendship.new
-    f[:people] = [f1, f2]
-    return f
-  end
-  
-  def friend_of
-    [
-      Storage::Key.new(self[:people][0], self[:people][1]), 
-      Storage::Key.new(self[:people][1], self[:people][0])
-    ]
-  end
-  
-  def to_s
-    "Friendship: A:  #{self[:people][0]} \t B: #{self[:people][1]}"
-  end
-  
-  indexed_by :friend_of
-end
diff --git a/test/test_entity.rb b/test/test_entity.rb
index 61331af..0ddef49 100644
--- a/test/test_entity.rb
+++ b/test/test_entity.rb
@@ -85,6 +85,73 @@ end
 
 require 'examples/social'
 
+class TC_FoFTest < Test::Unit::TestCase
+  def setup
+    SCADS_SERVER.registerType(:Profile)
+    SCADS_SERVER.registerType(:Friendship)
+    
+    # create 10 profiles
+    @@profiles ||= []
+    return unless @@profiles == []
+    srand 42
+    (1..10).each do |val|
+      p = Profile.new
+      p[:birthday] = rand 1000
+      p[:name] = "person" + val.to_s
+      p.save
+      @@profiles << p
+    end  
+  end
+  
+  def test_fof_dual_direction
+    # create some arbitrary friendships
+    f12 = Friendship.create(@@profiles[0],@@profiles[1])
+    f12.save
+    f23 = Friendship.create(@@profiles[1],@@profiles[2])
+    f23.save
+    SCADS_SERVER.workqueue.clean # make sure all friendships are in place before proceeding
+    
+    # person2 is a friend of both person1 and person3
+    # calling friend_of_friend on friendship should result in two indexes connecting person1 and person3
+    fof1 = f23.friend_of_friend
+    test1a = Storage::Key.new(@@profiles[2],@@profiles[0]) # fof: person3 and person1
+    test1b = Storage::Key.new(@@profiles[0],@@profiles[2]) # fof: person1 and person3
+    
+    SCADS_SERVER.workqueue.clean # make sure friend of friend construction is done
+    assert_equal(2,fof1.size,"should be two directions for one fof relationship")
+    assert_equal(0,test1a.keytuple<=>fof1[0].keytuple,"fof one way don't match")
+    assert_equal(0,test1b.keytuple<=>fof1[1].keytuple,"fof other way don't match")
+  end
+  
+  def test_no_fof
+     # create some arbitrary friendships
+      f12 = Friendship.create(@@profiles[0],@@profiles[1])
+      f12.save
+      f34 = Friendship.create(@@profiles[2],@@profiles[3])
+      f34.save
+      SCADS_SERVER.workqueue.clean # make sure all friendships are in place before proceeding
+      
+      fof1 = f12.friend_of_friend # should not bridge gap to person3 or person4
+      SCADS_SERVER.workqueue.clean # make sure friend of friend construction is done
+      assert_equal(true,fof1.empty?,"there should be no fofs generated")
+  end
+  
+  def test_no_fof_to_friend
+    # create some arbitrary friendships
+      f12 = Friendship.create(@@profiles[0],@@profiles[1])
+      f12.save
+      f23 = Friendship.create(@@profiles[1],@@profiles[2])
+      f23.save
+      f13 = Friendship.create(@@profiles[0],@@profiles[2])
+      f13.save
+      SCADS_SERVER.workqueue.clean # make sure all friendships are in place before proceeding
+      
+      fof1 = f12.friend_of_friend
+      SCADS_SERVER.workqueue.clean # make sure friend of friend construction is done
+      assert_equal(true,fof1.empty?,"there should be no fofs generated")
+  end
+end
+
 class TC_SocialNetworkTest < Test::Unit::TestCase 
 
   def setup
